% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Chapter: Background and context
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter{Background and context}
\label{cpt:background}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Rascal
%\section{Rascal}
% // Not explaining Rascal for now
% - Rascal is a Meta-progrmaming language which is used throughout the project.
% - Rebel is written in Rascal.\\
% - The generators are also written in Rascal.\\
% - Our test generator is also written in Rascal. However, the resulting tests are written in Scala.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Rebel
\section{Rebel}
\pinfo{About Rebel}
\textit{Rebel} is a domain specific language that focuses on the banking
industry~\cite{stoel2016solving}. Banking products can be specified in the
language, with the use of \textit{Rebel} types like \textit{Money},
\textit{IBAN} and \textit{Percentage}. In \autoref{ssct:2_rebel_example} an
example of a \textit{Rebel} specification is described.\\
\\
The tool chain of \textit{Rebel} allows to check, visualize and simulate the specified
banking product. For checking and simulation an efficient, state-of-the-art SMT
solver is being used called \textit{Z3}, which is developed by
\textit{Microsoft}~\cite{de2008z3}. \textit{Rebel} is written in \textit{Rascal}
and is developed by the \textit{ING} in corporation with the \textit{CWI}.
Currently, the tool chain of \textit{Rebel} is also written in
\textit{Rascal}.\\
\\
\pinfo{What Rebel exactly checks}
Checking a \textit{Rebel} specification is based on Bounded Model
Checking~\cite{stoel2016solving}. The \textit{Rebel} specification is being
translated to SMT constraints, next, the \textit{Z3} solver is being used to
check whether the specification is consistent. An inconsistent specification
means that a counter example has been found (meaning that a trace is found for which an
invariant doesn't hold). It is bounded since it only checks if a counter example
can be found within a certain number of steps. Besides checking the
specification, the specification can also be simulated. For simulation, the SMT
solver is also being used to determine whether a transition can happen. After
successfully checking the specification, meaning that no counter examples could
be found, the result is still that the specification `might' be valid. As the
checking method is bounded, it stops at a certain point (which, in the
\textit{Rebel} toolchain, is defined as the maximum depth of the traces that can
be used for checking). This means that there can still be a long or untested
trace for which the invariant doesn't hold.\\
\\
\pinfo{Generating system from specification}
From the \textit{Rebel} specification, a system can be generated by using a
generator which is developed by \textit{ING}. The generators are also written in
\textit{Rascal}. This requires a specification that is consistent and that does
not trigger errors by the type checker.

% % % % % % % % % % % % %
% Subsection: A Rebel example
\subsection{A Rebel example}
\label{ssct:2_rebel_example}
In \autoref{lst:ch2_rebel_example_specification} an example of a simple bank
account specification is shown in \textit{Rebel}. In this specification, an
account can be opened and money can be deposited to an opened account.
% Listing
\begin{sourcecode}[!ht]
\begin{lstlisting}[language=Rebel]
module simple_account.Account
import simple_account.Library

specification Account {
	fields {
		accountNumber: IBAN @key
		balance: Money
	}
	events {
	  openAccount[]
		deposit[]
	}
	lifeCycle {
		initial init -> opened: openAccount
		opened -> opened: deposit
		final opened
	}
}
\end{lstlisting}
\caption{A simple account specification in \textit{Rebel}.}
\label{lst:ch2_rebel_example_specification}
\end{sourcecode}
\FloatBarrier\noindent
% End listing
The \textit{module} keyword describes the module of this specification. The
\textit{import} statement is used to import logic from another file, which we
will cover when describing the \textit{events} block. The specification of the
account itself is defined in the \textit{specification} block, which consists
of the following three blocks:

% FIELDS
\subsubsection{Fields}
The \textit{fields} block describes which data is available in this bank
account. In this case, \textit{accountNumber} and \textit{balance} which are of
type \textit{IBAN} and \textit{Money} respectively. The \textit{accountNumber}
is used as identifier for this account specification, because of the
\textit{@key} notation behind the type.

% LIFE CYCLE
\subsubsection{Life cycle}
The \textit{lifeCycle} block describes the life cycle, it can be seen as the
life cycle of a finite state machine. It describes the states and the
transitions between them. It also defines the \textit{initial} and
\textit{final} state. Note that the transitions between these states are the
events that have been defined in the specification.

% EVENTS
\subsubsection{Events}
In the \textit{events} block the events for this specification are described.
The optional parameters of the event definition can be overloaded inside the
brackets. Note that the implementation of the events are not described here.
This is defined in another file called \textit{Library}, shown in
\autoref{lst:ch2_rebel_example_library}.
% Listing
\begin{sourcecode}[!ht]
\begin{lstlisting}[language=Rebel]
module simple_account.Library
import simple_account.Account

event openAccount[minimalDeposit: Money = EUR 0.00](initialDeposit: Money) {
    preconditions {
        initialDeposit >= minimalDeposit;
    }
    postconditions {
        new this.balance == initialDeposit;
    }
}
event deposit(amount: Money) {
    preconditions {
        amount > EUR 0.00;
    }
    postconditions {
        new this.balance == this.balance + amount;
    }
}
\end{lstlisting}
\caption{The library for the simple account example in \textit{Rebel}.}
\label{lst:ch2_rebel_example_library}
\end{sourcecode}
\FloatBarrier\noindent
% End listing
An event definition can consist of \textit{preconditions},
\textit{postconditions} and a \textit{sync} block. The \textit{sync} block
defines that each operation inside that block should execute synchronously,
without the interaction of other events in the meanwhile. However, in this
simple specification the \textit{sync} block is not used.\\
\\
The \textit{preconditions} and \textit{postconditions} blocks contain
expressions and can use functions. These functions can be defined in
\textit{Rebel} too. The \textit{new} keyword in the \textit{postconditions}
block describe that the value of the field should be updated when the event
transition takes place.

% % % % % % % % % % % % %
% Subsection: Rebel checker versus our approach
\subsection{Rebel checker versus our approach}
Although the specification is being
checked by using bounded model checking, the generated system is not being
checked against the specification. Unfortunately, it is not possible to also use
the bounded model checker to test the generator or the generated system. As the
generated system is written in \textit{Scala}, while the existing checker only
supports checking the \textit{Rebel} specification itself.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: The Scala/Akka generator
\section{The Scala/Akka generator}
% Generator -> Scala, Akka, test config missing in prototype, thus we add that ourselves. Using Doubles for Percentage. Might expect problems on here. Known problems with Doubles etc.
\pinfo{Different generators, we use Scala/Akka generator}
There are multiple generators developed within \textit{ING}. The generators are
different in that the resulting product is written in a different language or
uses a different implementation, like database or messaging layer. Each
generator is written in \textit{Rascal}. \textit{Rebel} defines the states and
the transitions between the states in the \textit{lifeCycle} block, which can be
seen as the Finite State Machine definition of the specified product. The
Scala/Akka generator is one of these generators. It generates a system that is
written in \textit{Scala}, uses \textit{Akka}~\cite{siteAkka2017} as actor
system and uses \textit{Cassandra}~\cite{siteCassandra2016} as database. A resulting
system of this generator is also tested thoroughly with performance tests, to
reason about how well this system performs with its architecture. However, this
does not check the implementation of the generated system against the
\textit{Rebel} specification. This generator is often used within experiments
inside \textit{ING} and is considered the most mature generator among the
currently developed generators. Because of this, it's interesting if we
encounter yet unknown problems in the generator itself or the resulting system.
Throughout this thesis, we will only make use of this generator.\\
\\
\pinfo{Short explanation on implementation generated system + why}
A specification can be defined in terms of a Labeled Transition
System~\cite{stoel2016solving}%\todo{SRC-Rebel-Reference on smt check chapter. Do we need that source? ("As introduced by Keller 1876") Just citing Rebel is probably OK too}
, containing the states, the data fields and the transitions between the states
along with the pre- and post conditions of the transitions. The generated system
is based on these states and transitions defined in \textit{Rebel}, resulting in
a system that works like an Extended Finite State Machine. Thus the generated program
also implements it like states and transitions between them. An instance of a
banking product can have fields and is in a specific state. In order to go to
another state, a transition can be done which might have pre- or post conditions.
In case there are pre- or post conditions, these have to be satisfied in order to
successfully complete a transition.\\
\\
\pinfo{Diff types: known/expected problems. We have to specify expected properties}
\textit{Rebel} introduces custom types, such as \textit{IBAN},
\textit{Percentage} and \textit{Money}, these types are not supported natively
in \textit{Scala}. For these cases, a library or own implementation is used. An
example is the \textit{Money} type, which is available in the
\textit{Squants}~\cite{siteSquants2017} library. The generated system uses this
library to deal with the \textit{Money} type and its operations. Another example
is the \textit{Percentage} type, which is simply translated by calling a method
\code{percentage()}. In order to conclude that the generated program is doing
something incorrectly, we have to specify what the expected properties are in
\textit{Rebel}.


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Property-based testing
\section{Property-based testing}
\pinfo{About property-based testing}
With property-based testing properties are defined and being tested. It uses random values as input and checks whether the defined property holds. After a certain number of succeeding cases the test succeeds and the next property is being checked.\\
\\
\pinfo{About QuickCheck}
A well-known tool which is based on property-based testing is
\textit{QuickCheck}, which is written for
\textit{Haskell}~\cite{claessen2011quickcheck}. It tests the properties
automatically by using random input values. For each property
\textit{QuickCheck} tries to find counter examples, which are a set of values
for which the desired property does not hold. If 100 test cases are succeeding
in a row, it goes on to the next property. In case it found a counter example,
it will try to minimize the values to try to report the edge case of the
failure. However, one might have properties that only hold under certain
conditions. For this \textit{QuickCheck} allows using preconditions. Although,
this doesn't work well for every case as \textit{QuickCheck} will just generate
new pairs of values in case the precondition didn't hold for the generated set
of values. An example of this is where 2 of the input values have to be equal,
the chance that this happens with random values is rather low.
\textit{QuickCheck} will try to generate new values each time, with a maximum of
1000 tries by default. In case this maximum is reached, it reports the case as
``untested'' and continues to the next property. Note that these values of 100 and
1000 are the default values, these can be adjusted when needed.\\
\\
\pinfo{About the ports of it}
% Different ports, for example FortressCheck
Due to the effectiveness of \textit{QuickCheck}, many ports for other languages
were written. Most ports implement the basics of \textit{QuickCheck},
additionally, each port could have added extra features. Examples of some ports
are \textit{FortressCheck} (for \textit{Fortran})~\cite{kang2011fortresscheck}
and \textit{ScalaCheck} (for \textit{Scala})~\cite{siteScalaCheck2015}.
\textit{FortressCheck} supports polymorphic types and, unlike
\textit{QuickCheck}, heavily uses reflection for its value generation to solve
certain problems with polymorphic constructs. Although \textit{Scala} supports
polymorphism, \textit{ScalaCheck} does not use reflection to test
this~\cite{kang2011fortresscheck}.\\
\\
\pinfo{No QuickCheck for Rebel, not using ScalaCheck}
There is no \textit{QuickCheck} implementation for \textit{Rebel}. As the
generated system is written in \textit{Scala}, \textit{ScalaCheck} might be
applicable for us. However, this would result in using \textit{ScalaCheck} as a
black box, implementing the random functionality ourselves makes sure we know
what is going on. Thus resulting in a white box implementation for our test
framework.\\
\\
\pinfo{Custom modifications}
We can also modify it to our needs when we want to improve our test suite. One
of the things that we want to improve is to generate values under certain
conditions. For example, if a property only holds under a certain condition, the
chance that random values satisfy the condition can be very low. Resulting in a
test case that wouldn't do anything most of the time. An example of such a
property is \textit{Symmetry} (\code{x == y $\implies$ y == x}). %, which defines that y should be equal to x iff x is equal to y.
Additionally, we might also need to slightly interact with other components,
such as the messaging layer, that the generated system uses. This could make the
implementation more complicated when using \textit{ScalaCheck} due to the format
of a property test when using \textit{ScalaCheck}.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Terminology
\section{Terminology}
\pinfo{Confusing terminologies and abstractions}
In this thesis there are some levels of abstraction, the terminology used
throughout this theses can cause confusion. Words like `specification',
`properties' and `tests' generally can have a different meaning depending on the
context. In this section, we describe the confusing terminologies and
abstractions in detail.

\begin{description}
\item[Specification]\hfill\\
In this thesis we use the word ``specification'' exclusively to indicate
banking products described in the \textit{Rebel} language. This includes the
state machines (life cycle), pre and post-conditions and logical invariants.

\item[Properties]\hfill\\
We use the word ``property'' to describe semantic properties of the
\textit{Rebel} language. The set of properties we introduce in this thesis can
be seen as a partial ``specification'' of the semantics of \textit{Rebel}, but
we do not use this word to avoid confusion. We stick with ``properties''.

\item[Implicative property]\hfill\\
A ``property'' that uses the implication ($\implies$) operator in its
definition.

\item[Generator(s)]\hfill\\
The generator(s) that can be used to generate a system based on a
``specification''. When using the term ``the generator'', we refer to the
Scala/Akka generator which is the only generator that we use throughout this
thesis.

\item[Test framework]\hfill\\
The test framework that was developed during this thesis. Which builds the
specification, generates a system from the specification by using the generator,
generates the test suite and runs the test suite against the generated system.

%\item[System Under Test (SUT)]\hfill\\
%The system against which the tests are being run. This system is generated by using a generator. Also referred to as ``generated system'' in the context of generating the ``system under test''.

\item[Tests]\hfill\\
The generated tests by the ``test framework'', intended to check whether a
certain ``property'' holds.

\item[Test suite]\hfill\\
The collection of generated tests by the ``test framework'', along with its configurations which can
be run to test the generated system. Note that the test suite initially doesn't
exist. Instead, it is being generated and added to ``the generated system'' when
we run the ``test framework''.

\item[Events]\hfill\\
The event definitions in a ``specification'', these define the transitions
between the states.

\item[Scala Build Tool (SBT)]\hfill\\
The tool that is used to compile and run the ``generated system'' and the
``test suite''.

\item[Concrete Syntax Tree (CST)]\hfill\\
A ``specification'' can be checked and built. This results in a ``CST''
containing the data of the specification. This ``CST'' is being used by the
toolchain of \textit{Rebel} and by the ``test framework''.

% Common knowledge, right? :
%\item[Invariant(s):]\hfill\\
%The invariant of a \textit{Rebel} specification defines conditions that should always hold during the life cycle of an instance of the product.
%\item[Read–Eval–Print Loop (REPL)]\hfill\\
%...
%\item[Application Programming Interface (API)]\hfill\\
%...
\end{description}
