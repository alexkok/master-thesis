% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Chapter: Background and context
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter{Background and context}
\label{chp:background_and_context}
...
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Rascal
%\section{Rascal}
% // Not explaining Rascal for now
% - Rascal is a Meta-progrmaming language which is used throughout the project.
% - Rebel is written in Rascal.\\
% - The generators are also written in Rascal.\\
% - Our test generator is also written in Rascal. However, the resulting tests are written in Scala.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Rebel
\section{Rebel}
\pinfo{About Rebel}
Rebel is a domain specific language that focuses on the banking industry \cite{stoel2016solving}. Banking products can be specified in the language, with the use of types like \textit{Money} and \textit{Iban}. The tool chain of Rebel allows to check, visualize and simulate the specified banking product. For checking and simulation an efficient, state-of-the-art SMT solver is being used called \textit{Z3}, which is developed by Microsoft \cite{de2008z3}. \textit{Rebel} is written in Rascal and is developed by the \textit{ING} in corporation with the CWI. Currently, the tool chain of Rebel is also written in \textit{Rascal}.\\
\\
\pinfo{What Rebel exactly checks}
Checking a Rebel specification is based on Bounded Model Checking \cite{stoel2016solving}. The \textit{Rebel} specification is being translated to SMT constraints, next, the \textit{Z3} solver is being used to check whether the specification is inconsistent. An inconsistent specification means that a counter example has been found (a trace is found for which an invariant doesn't hold). It is bounded since it only checks if a counter example can be found within a certain amount of steps. Besides checking the specification, the specification can also be simulated. For simulation, the SMT solver is also being used to determine whether a transition can happen. After successfully checking the specification, meaning that no counter examples could be found, the result is still that the specification 'might' be valid. As the checking method is bounded, it stops at a certain point (bounded, for example, maximum depth of traces used for checking). This means that there can be a long or untested trace such that a counter example can exist.\\
\\
\pinfo{Generating system from specification}
From the Rebel specification, a system can be generated by using a generator which is developed by \textit{ING}. The generators are also written in \textit{Rascal}. This requires a specification that is consistent and that does not trigger errors by the type checker. Although the specification is being checked by using bounded model checking, the generated system is not being checked against the specification. Unfortunately, it is not possible to also use the bounded model checker to test the generator or the the generated system. As the generated system is written in Scala, while the checker only supports checking a \textit{Rebel} specification.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: The Scala/Akka generator
\section{The Scala/Akka generator}
% Generator -> Scala, Akka, test config missing in prototype, thus we add that ourselves. Using Doubles for Percentage. Might expect problems on here. Known problems with Doubles etc.
\pinfo{Different generators, we use Scala/Akka generator}
There are multiple generators developed within \textit{ING}. The generators are different in that the resulting product is written in a different language or uses a different implementation, like database or messaging layer. Each generator is written in Rascal. Rebel defines the states and the transitions between the states in the \textit{lifecycle} block, which can be seen as the Finite State Machine definition of the specified product. The Scala/Akka generator is one of these generators. It generates a system that is written in \textit{Scala}, uses \textit{Akka}~\cite{siteAkka2017} as actor system and uses Cassandra~\cite{siteCassandra2016} as database. A resulting system of this generator is also tested thoroughly with performance tests, to reason about how well this system performs with its architecture. However, this does not check the implementation of the generated system against the \textit{Rebel} specification. This generator is often used within experiments inside ING and is considered the most mature generator among the currently developed generators. Because of this, it's interesting if we encounter yet unknown problems in the generator itself or the resulting system. Throughout this project, we will only make use of this generator.\\
\\
\pinfo{Short explanation on implementation generated system + why}
A specification can be defined in terms of a Labeled Transition System~\cite{stoel2016solving}%\todo{SRC-Rebel-Reference on smt check chapter. Do we need that source? ("As introduced by Keller 1876") Just citing Rebel is probably OK too}
, containing the states, the data fields and the transitions between the states along with the pre- and post conditions of the transitions. The generated system is based on these states and transitions defined in \textit{Rebel}, resulting in a system that works like a Labeled Transition System. Thus the generated program also implements it like states and transitions between them. An instance of a banking product can have fields and is in a specific state. In order to go to another state, a transition can be done which might have pre- or postconditions. In case there are pre- or postconditions, these have to be satisfied in order to successfully complete a transition.\\
\\
\pinfo{Adding test configuration, but not relevant for the project}
Although this generator is the most mature and often used in experiments within ING, it is still used as a prototype. The resulting system is thus not production ready, as this requires some more actions. One of these is that the resulting system should have tests which test the generated system. The generated system doesn't contain anything that's related to testing yet. So to make use of the testing libraries in Scala, we will need to add the test dependencies to the build file of the project and add a configuration file for Akka. This is done when we initialize the test suit and can be found in the source. However, we will not cover these settings in detail, as these are not relevant for this project.\\
\\
\pinfo{Diff types: known/expected problems. We have to specify expected properties}
\textit{Rebel} introduces custom types, such as \textit{Iban}, \textit{Percentage} and \textit{Money}, these types are not supported natively in Scala. For these cases, a library or own implementation is used. An example is the \textit{Money} type, which is available in the Squants \cite{siteSquants2017} library. The generated system uses this library to deal with the Money type and its operations. Another example is the \textit{Percentage} type, which is simply translated by calling a method \code{percentage()}. However, the return type of that method is a \textit{Double}, which is is a type using Floating-Point Arithmetic, which is known to have precision loss errors \cite{goldberg1991every}. In \textit{Rebel} the \textit{Percentage} type is actually defined as a whole number, so precision errors are probably not expected when using Rebel. In \textit{Rascal}, there are \textit{real} values, which basically always should contain the value as we expect it, without rounding errors. Since \textit{Rebel} is written in \textit{Rascal}, we could reason that the expected behaviour is to what \textit{Rascal} does, which is providing real values without precision loss\footnote{The \textit{real} type in \textit{Rascal} uses a precision of 60 decimals when expressions cannot be expressed, for example, 1/3.}. In order to conclude that the generated program is doing something incorrectly, we have to specify what properties are expected in \textit{Rebel} during this project.


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Property based testing
\section{Property based testing}
\pinfo{About property based testing}
With property based testing properties are defined and being tested. It uses random values as input and checks whether the defined property holds. After a certain amount of succeeding cases the test succeeds and the next property is being checked.\\
\\
\pinfo{About QuickCheck}
A well-known tool which is based on property based testing is
\textit{QuickCheck}, which is written for Haskell \cite{claessen2011quickcheck}.
It tests the properties automatically by using random input values. For each property \textit{QuickCheck} tries to find counter examples, which are a set of values for which the desired property does not hold. If 100 test cases are succeeding in a row, it goes on to the next property. In case it found a counter example, it will try to minimize the values to try to report the edge case of the failure. However, one might have properties that only hold under certain conditions. For this \textit{QuickCheck} allows using preconditions. Although, this doesn't work well for every case as QuickCheck will just generate new pairs of values in case the precondition didn't hold for the generated set of values. An example of this is where 2 of the input values have to be equal, the chance that this happens with random values is rather low. \textit{QuickCheck} will try to generate new values each time, with a maximum of 1000 tries by default. In case this maximum is reached, it reports the case as "untested" and continues to the next property. Note that these values of 100 and 1000 are the default values, these can be adjusted when needed.\\
\\
\pinfo{About the ports of it}
% Different ports, for example FortressCheck
Due to the effectiveness of \textit{QuickCheck}, many ports for other languages were written. Most ports implement the basics of \textit{QuickCheck}, additionally, each port could have added extra features. Examples of some ports are FortressCheck (for Fortran) \cite{kang2011fortresscheck} and ScalaCheck (for Scala) \cite{siteScalaCheck2015}. FortressCheck supports polymorphic types and, unlike QuickCheck, heavily uses reflection for its value generation to solve certain problems with polymorphic constructs. Although Scala supports polymorphism, ScalaCheck does not use reflection to test this \cite{kang2011fortresscheck}.\\
\\
\pinfo{No QuickCheck for Rebel, not using ScalaCheck}
There is no \textit{QuickCheck} implementation for \textit{Rebel}. As the generated system is written in \textit{Scala}, ScalaCheck might be applicable to us. However, this would result in using \textit{ScalaCheck} as a black box, implementing the random functionality ourselves makes sure we know what is going on. Thus resulting in a white box implementation for our test framework.\\
\\
\pinfo{Custom modifications}
We can also modify it to our needs when we want to improve our test suite. One of the things that we might want to improve is to generate values under certain conditions. For example, if a property only holds under a certain condition, the chance that random values satisfy the condition can be very low. Resulting in a test case that wouldn't do anything most of the time. An example of such a property is \textit{Transitivity} (\code{x == y $\implies$ y == x}).%, which defines that y should be equal to x iff x is equal to y.
Additionally, we might also need to slightly interact with other components, such as the messaging layer, that the generated system uses. This could make the implementation more complicated when using \textit{ScalaCheck}.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Terminology
\section{Terminology}
\pinfo{Confusing terminologies and abstractions}
In this thesis there are some levels of abstraction, the terminology used throughout this theses can cause confusion. Words like "specification", "properties" and "tests" generally can have a different meaning depending on the context. In this section we describe the confusing terminologies and abstractions in detail.

\begin{description}
\item[Specification]\hfill\\
In this thesis we use the word “specification” exclusively to indicate banking products described in the \textit{Rebel} language. This includes the state machines (life cycle), pre and post-conditions and logical invariants.

\item[Properties]\hfill\\
We use the word “property” to describe semantic properties of the \textit{Rebel} language. The set of properties we introduce in this thesis can be seen as a partial “specification” of the semantics of Rebel, but we do not use this word to avoid confusion. We stick with “properties”.

\item[Implicative property]\hfill\\
A "property" that uses the implication ($\implies$) operator in it's definition.

\item[Generator(s)]\hfill\\
The generator(s) that can be used to generate a system based on a "specification". When using the term "the generator", we refer to the Scala/Akka generator which we use throughout this thesis.

\item[Test framework]\hfill\\
The test framework that was developed during this thesis. Which builds the specification, generates a system from the specification by using the generator, generates the test suite and runs the test suit against the generated system.

\item[System Under Test (SUT)]\hfill\\
The system against which the tests are being run. This system is generated by using a generator. Also referred to as "the generated system" in the context of generating the "system under test".

\item[Tests]\hfill\\
A generated test by the "test framework", intended to check whether a certain "property" holds.

\item[Test suite]\hfill\\
The collection of generated test cases, along with its configurations which can be run to test the generated system. Note that the test suite initially doesn't exist. Instead, it is being generated and added to "the generated system" when we run the "test framework".

\item[Events]\hfill\\
The event definitions in a "specification", these can be seen as transitions in a Labeled Transition System.

\item[Scala Build Tool (SBT)]\hfill\\
The tool that is used to compile and run "the generated system". Also used to run the "generated test suite".

%item[Invariant(s):] The invariant of a Rebel specification defines conditions that should always hold during the lifecycle of an instance of the product.

\end{description}
