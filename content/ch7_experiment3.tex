% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Chapter: Experiment 3
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter{Experiment 3: Improving the value generation}
\label{cpt:experiment3}
In the second experiment (\autoref{cpt:experiment2}) it was found that the
property definition for using division with the \textit{Monye} type wasn't clear
enough in that it couldn't be satisfied the way how it was specified. In this
experiment we aim to improve this. We update the existing definition such that
it can now be correctly.\\
\\
Another result from the second experiment was that the value generation was not
very dynamic when new properties were being added. It should be possible to add
additional properties to the specification, which are then being tested
automatically by the test framework. To do this, the value generator will be
updated too, such that it uses the preconditions in the event definitions to
determine the parameter values. Additional properties can then be added to test
the generator.\\
\\
In this experiment we will use an updated version of the generator. In this
version the precision errors that were found in the first experiment are fixed,
such that we can focus on possible additional errors that might occur.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Method
\section{Method}
The property definition of division will be updated for this experiment, because
the first definition did not take the division problem into account. There was
also no definition for rounding the value, as the value was expected to hold the
exact value. We will update the definition by using a round function. By using
this, the fixed properties can be defined which can then be tested by the test
framework. These are fixed because these property definitions turned out to be
incomplete or incorrect in the second experiment (\autoref{cpt:experiment2}).\\
\\
Besides updating the property definitions that were using division, additional
property definitions are being added to test more of the generator. However, as
we have seen in the second experiment, the values generator was not very
dynamic. Which resulted in that it had to be modified in case an implicative
property is being added to the specification. This is the second thing that
should be improved, such that additional (implicative) properties do not require
modifications to the values generator.

% % % % % % % % % % % % %
% Subsection: Updating property definitions
\subsection{Updating property definitions}
\todo{Source for division - rounding?}
\todo{Rephrase}
\pinfo{Round method}
Initially there were only 2 property definitions that were using division, which both are being updated. In order to check for the values such that the property definition can be used, we implement a \code{round()} method in the \textit{Rebel} specification. This \textit{round} method is intended to return a value which can be used to define the expected behaviour when using division with the \textit{Money} type.\\
\\
\pinfo{Defining, updating and adding more}
In addition to updating the existing properties that are using division, more properties can be added. For example, properties of inequality when using division, as the ones that were defined for
division only used equality. Also other properties like the subtraction property can
be added and more definitions for multiplication and additivity
can be added to the existing list of property definitions that we defined for \textit{Rebel}. The
additional property definitions for division, multiplication, additivity and
subtraction fall under the ``Properties of equality and inequality'' category
and are defined in \autoref{ssct:properties_definitions_additionalproperties},
along with the updated definitions for the existing property definitions that
use division. \todo{Add added properties by name as list}\\
\\
\pinfo{Round method implementation + why}
The properties using division are now using the \code{round()} method in its d
efinition. \textit{Rebel} does not provide a way to round a value, which is why
we need to define the function in the specification. In \textit{Rebel} a
function is defined as an expression that is being executed whenever the
function is being called. Unfortunately, there is no way in \textit{Rebel} to
define the \textit{Scala} implementation of this \textit{round} function. As a
workaround, we define the implementation as a \textit{String} and modify the
generator such that the function's implementation is the content of the
\textit{String} (removing the quotes). The \textit{round} method rounds the
\textit{Money} value to a maximum of 4 decimals. The fifth decimal is being
rounded by using ``HALF_UP'' technique
\todo{Maybe a source or so? Or common knowledge?}. The function implementation
in the \textit{Rebel} specification is shown in
\autoref{lst:experiment3_rebel_round_implementation}.
% Listing
\FloatBarrier
\begin{sourcecode}[!ht]
\begin{lstlisting}[language=Rebel]
function round(money: Money): Money =
    "money.currency(money.amount.setScale(4, RoundingMode.HALF_UP))";
\end{lstlisting}
\caption{The updated event definition of the \textit{Symmetric} property}
\label{lst:experiment3_rebel_round_implementation}
\end{sourcecode}
\FloatBarrier
% End listing

% % % % % % % % % % % % %
% Subsection: Improving dynamicallity
\subsection{Improving dynamicallity}
\pinfo{Using preconditions}
The additional properties that are being added also using implication in their definitions. In the second experiment (\autoref{cpt:experiment2}), the value generator was not dynamic enough in that it requires modifications for each implicative property that is being added. In this experiment we aim to improve this, by using the defined preconditions to determine the input values.\\
\\
A custom generator is being created that uses the preconditions to determine the input values. Note that this can be seen as an update to the generator that was created in \autoref{cpt:experiment2}. This value generator parses the preconditions and intends to generate values based on these conditions. Since the expressions inside the preconditions might become quite complex, we focus on a limited version of it, while still satisfying the requirements that are needed for the properties that have been defined in \autoref{cpt:properties}.\\
\\
Most properties are using single variables in its precondition statements. Some are using expressions on the left-hand or right-hand side of a statement, but not on both sides. The value generator that we implement will not support using expressions on both the left-hand and right-hand side, as generating values matching the condition can become complex. Instead, it requires to only have a variable on one side and either an expression or a variable on the other side.\\
\\
The code to generate the tuples of input values is shown in \autoref{lst:experiment3_value_generation_code}. We can separate this process into the following steps:
\def \valueGeneratorStepOne{Initialize value generation data}
\def \valueGeneratorStepTwo{Traverse and handle statements}
\def \valueGeneratorStepThree{Generate values for yet unassigned variables}
\def \valueGeneratorStepFour{Add values to resulting list}
\begin{enumerate}
  \item \valueGeneratorStepOne
  \item \valueGeneratorStepTwo
  \item \valueGeneratorStepThree
  \item \valueGeneratorStepFour
\end{enumerate}
% Listing
\FloatBarrier
\begin{sourcecode}[!ht]
\begin{lstlisting}[language=Rascal]
public list[list[Expr]] genValues(str eventName, Preconditions? preconditions, list[Parameter] transitionParams, int amount) {
    println("\> Generating values for event <eventName>");

    list[list[Expr]] valueList = [];
    for (int i <- [0..amount]) {
        calculatedParams = (); // Clear old data
        paramGenData = ("<p.name>" : <p.tipe, -9999.00, 9999.00, true> | p <- transitionParams);

        // Calculating
        for(/Statement s <- preconditions) {
            <lhs, rhs, operator> = extractStatementData(s.expr);
            handleConditionStatement(operator, lhs, rhs);
        }

        // Check whether all are determined, if not, determine those using the randomValueProps data
        for (Parameter p <- transitionParams, !calculatedParams["<p.name>"]?) {
            calculatedParams["<p.name>"] = calculateExpression(p.name);
        }

        // Add to list
        valueList += [[getExprForVar("<p.name>") | p <- transitionParams]];
    }
    return valueList;
}
\end{lstlisting}
\caption{The updated event definition of the \textit{Symmetric} property}
\label{lst:experiment3_value_generation_code}
\end{sourcecode}
\FloatBarrier
% End listing

In the following sections we describe each step in detail.

% Initialize value generation data for each variable
\subsubsection{1. \valueGeneratorStepOne}
To generate a single value, some data is being hold to keep track of the conditions to which a certain value should when it is being generated. These conditions are minimum value, maximum value and whether the zero value is allowed. Additionally the result type of the variable is stored, used when generating the final value. This data is stored in a tuple and called \textit{RandomValueProps} by using an \textit{alias} in \textit{Rascal}. This definition is shown in \autoref{lst:experiment3_alias_definition_randomvalueprops}.
% Listing
\FloatBarrier
\begin{sourcecode}[!ht]
\begin{lstlisting}[language=Rascal]
// Minimum: including. So: if 0, then 0 can be a result value when determining it random.
// Maximum: including. So: if 10, then 10.00 is max result value when determining random.
alias RandomValueProps = tuple[Type tipe, real min, real max, bool allowZero];
\end{lstlisting}
\caption{The updated event definition of the \textit{Symmetric} property}
\label{lst:experiment3_alias_definition_randomvalueprops}
\end{sourcecode}
\FloatBarrier
% End listing
The value generator initializes the \textit{RandomValueProps} for each input variable (\autoref{lst:experiment3_value_generation_code},~Line~7). Setting the minimum and maximum value to a default value and allowing zero by default.

% Traverse statements in the precondition block and handle these based on the expression
\subsubsection{2. \valueGeneratorStepTwo}
Each statement in the preconditions block is being checked (\autoref{lst:experiment3_value_generation_code},~Line~9 -13). The \textit{handleStatement()} method handles each statement. The actions done by this method depend on the operators used in the statement that is being handled.\\
\\
In case of an expression that only contains variables and uses equality (for example, \textit{x == y}), the value generator assigns a random value to \textit{x} and assigns the same value to \textit{y}. In case of inequality (\textit{x > y}), the value generator also assigns a random value to \textit{x}, but adjusts the minimum or maximum bounds of the \textit{y} value such that it satisfies the condition.\\
\\
In case there is an expression on one side (for example, \textit{x * y == z}), the expression will be evaluated first. In this case, random values will be assigned to \textit{x} and \textit{y}. Next, the expression can be evaluated and the result of that is being assigned to \textit{z}. The same is done with inequality relations, but then the minimum or maximum bounds are being set based on the operator.\\
\\
Having expressions on both the left-hand and the right-hand side of the expression is unsupported. The \textit{handleStatement()} method will throw an error in case this happens.

% Generate values for yet unassigned variables
\subsubsection{3. \valueGeneratorStepThree}
When handling each expression, some variables already get an assigned value. However, some variables might only have their \textit{RandomValueProps} updated but do not have an assigned value yet. In this step these variables, that do not have a value yet, are being assigned a value based on their \textit{RandomValueProps} (\autoref{lst:experiment3_value_generation_code},~Line~15-18).

% Add values to resulting list
\subsubsection{4. \valueGeneratorStepFour}
The values that have been determined are being added to the list of generated input values (\autoref{lst:experiment3_value_generation_code},~Line~21). In the end the list is being returned, containing all the generated input values that match the preconditions of the event.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Results
\section{Results}
% - Run, tests succeed (hopefully)
Running the test framework with the addition of the additional properties (\autoref{ssct:properties_definitions_additionalproperties}), results in no additional failing tests compared to the first experiment. The log is shown in \_\_\_. Remember that the test framework is run with the generator in which the precision problems related to the \textit{Money} type are fixed (otherwise there would be failing tests, due to the precision problems).
\todo{Add log}
\\
\\

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Analysis
\section{Analysis}
% - Test succeeding provided rounding
% - Case of rounding down, it fails (bigger number shows difference)
% - > Thus probably division does this too usually. FLooring causes difference
The tests are succeeding due to the implementation of the \textit{round()} method. It rounds the value of \textit{Money} to 4 decimals using the ``HALF\_UP'' rounding mode. The number 4 is chosen here to ensure that the property definitions should hold up to a precision of 4 decimals when using the round method. However, this can be modified in case a bigger precision is expected. Changing the number to 6 or 8 decimals do not change the results when looking at the amount of tests failing \todo{Check: is this true?}. However, changing the rounding mode would affect the results. When using ``DOWN'' as rounding mode, the tests that use the \textit{round()} method are failing\todo{Check: All division tests or just 'some'?}. This can be seen in \_\_\_, where ``DOWN'' is being used as rounding mode.\\
\todo{Add log}
\\
We stay with he implementation of ``HALF\_UP'' as rounding mode, as this is more in line with our expectations. When using the ``DOWN'' rounding mode, the resulting value is sometimes off with a difference value of 0.001, which is caused by this rounding mode.
\\
% - Adding properties didn't require a change in the value generator anymore
For this experiment, additional property definitions have been added to test the generator. The value generator now determines the values based on the preconditions of the properties. Thus the additional properties used in this experiment did not require more effort than defining these in the \textit{Rebel} specification. Compared to the second experiment (\autoref{cpt:experiment2}) this is a huge improvement, as it does not require the developer to modify the value generator in case implicative properties are being added.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Evaluation criteria
\section{Evaluation criteria}
% - Same coverage
% - No extra bugs found
%   > but increased dynamicallity. We have shown that additional properties can now be added to check, without needing to update the test framework
...

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Threats to validity
\section{Threats to validity}
% - Implementation error in our generator. However, we generate random values every run. (unlike Z3)
% > Running multiple times might give a fault-positive. High probability this is caused by the random operation that is done on the input values. This is a threat that came forth from experiment 2, and still exists here. - (Using > or < with 0 0 0 can happen because of this)

% - Existing approaches are available too, we only checked the Z3. But SageMath or others are possibilities too. However, this requires us to make such a tool compatible with the test framework. Our own implementation has shown to work for the properties we have defined. In case of more complex properties, it might be more useful to use another tool to determine these values.
...
% More reliable solving. Checked but not working as expected. Which is why we did our own generator
\subsubsection{Using existing solvers}
\pinfo{BMC possibility, tested. But not working}
Existing solvers could be used to determine a certain number of input values
that satisfy the preconditions. Since the \textit{Rebel} toolchain already makes
use of a bounded model checker to check a specification, this could be used to
translate an expression and retrieve values for which the condition holds.\\
\\
\pinfo{Checked using Z3, but returns same values all the time}
We have looked into this, by using the \textit{Z3} solver. However, the solver
always returns the same number when executing it multiple times. Which means
that the 100 values that we would ask from the generator, will be exactly the
same. A workaround would be to then add the number that was received earlier as
additional constraint, such that 100 unique values are being retrieved. But the
problem still remains, as executing the same script multiple times will result in
the same values. Another possibility would be to change the seed of the random generator that is being
used to generate the values, resulting in different values, however, then a random seed should be used each time the solver is being run to make the generated values unique. In order to integrate the solver with the test framework, the value generator has to be changed.\\
\\
An update to the value generator is required anyway to determine the input values based on the preconditions. In addition, some existing examples to check a \textit{Rebel} specification already take up some time. Which are probably related to the translations that have to be done and actually running the solver. We have not measured the exact duration of each step in this case, but we expect that generating 100 random input values by using this approach requires some time. Resulting in a huge run time increase for the test framework.\\
\\
Other solvers might work better for this approach, but these still require an update to the values generation part of the test framework to integrate with such solvers.


%
%\pinfo{Other possibilities, future work}
%There are other solvers available too, or other methods to generate values that
%match the condition. It would be useful to make the test framework more dynamic
%when such properties are being used.
