% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Chapter: Bibliography
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%{%\tiny
%\bibliographystyle{alphaurl}
\bibliographystyle{ieeetr}
\bibliography{thesis}
%}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Chapter: Appendices
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\appendix
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Appendix I: Property definitions of Rebel in Rebel
\chapter{Property definitions in Rebel}
\label{app:a_event_definitions}
% Listing
\begin{sourcecode}[!ht]
\begin{lstlisting}[language=Rebel]
event reflexiveEquality(x: Money) {
    postconditions {
       new this.result == ( x == x );
    }
}

event reflexiveInequalityLET(x: Money) {
    postconditions {
       new this.result == ( x <= x );
    }
}

event reflexiveInequalityGET(x: Money) {
    postconditions {
       new this.result == ( x >= x );
    }
}

event symmetric(x: Money, y:Money) {
    postconditions {
       new this.result == ( (x == y) ? y == x : True );
    }
}

event transitiveEquality(x: Money, y: Money, z: Money) {
    postconditions {
       new this.result == ( (x == y && y == z) ? x == z : True );
    }
}

event transitiveInequalityLT(x: Money, y: Money, z: Money) {
    postconditions {
       new this.result == ( (x < y && y < z) ? x < z : True );
    }
}

event transitiveInequalityGT(x: Money, y: Money, z: Money) {
    postconditions {
       new this.result == ( (x > y && y > z) ? x > z : True );
    }
}
\end{lstlisting}
\caption{The property definitions as \textit{Rebel} specification}
\end{sourcecode}
\FloatBarrier
% End listing
%
% Listing
\begin{sourcecode}[!ht]
\begin{lstlisting}[language=Rebel]
event transitiveInequalityLET(x: Money, y: Money, z: Money) {
    postconditions {
       new this.result == ( (x <= y && y <= z) ? x <= z : True );
    }
}

event transitiveInequalityGET(x: Money, y: Money, z: Money) {
    postconditions {
       new this.result == ( (x >= y && y >= z) ? x >= z : True );
    }
}

event additive(x: Money, y: Money, z: Money) {
    postconditions {
         new this.result == ( (x==y) ? x+z == y+z : True );
    }
}

event additive4params(x: Money, y: Money, z: Money, a: Money) {
    postconditions {
        new this.result == ( (x == y && z == a) ? x+z == y+a : True );
    }
}

event commutativeAddition(x: Money, y: Money) {
    postconditions {
        new this.result == ( x+y == y+x );
    }
}

event commutativeMultiplicationInteger1(x: Integer, y: Money) {
    postconditions {
        new this.result == ( x*y == y*x );
    }
}

event commutativeMultiplicationInteger2(x: Money, y: Integer) {
    postconditions {
        new this.result == ( x*y == y*x );
    }
}

event commutativeMultiplicationPercentage1(x: Percentage, y: Money) {
    postconditions {
        new this.result == ( x*y == y*x );
    }
}

event commutativeMultiplicationPercentage2(x: Money, y: Percentage) {
    postconditions {
        new this.result == ( x*y == y*x );
    }
}

event associativeAddition(x: Money, y: Money, z: Money) {
    postconditions {
        new this.result == ( (x+y)+z == x+(y+z) );
    }
}

event associativeMultiplicationInteger1(x: Integer, y: Integer, z: Money) {
    postconditions {
        new this.result == ( (x*y)*z == x*(y*z) );
    }
}
\end{lstlisting}
\caption{The property definitions as \textit{Rebel} specification (continued)}
\end{sourcecode}
\FloatBarrier
% End listing
%
% Listing
\begin{sourcecode}[!ht]
\begin{lstlisting}[language=Rebel]
event associativeMultiplicationInteger2(x: Money, y: Integer, z: Integer) {
    postconditions {
        new this.result == ( (x*y)*z == x*(y*z) );
    }
}

event associativeMultiplicationPercentage1(x: Money, y: Percentage, z: Integer) {
    postconditions {
        new this.result == ( (x*y)*z == x*(y*z) );
    }
}

event associativeMultiplicationPercentage2(x: Integer, y: Money, z: Percentage) {
    postconditions {
        new this.result == ( (x*y)*z == x*(y*z) );
    }
}

event distributiveInteger1(x: Money, y: Integer, z: Integer) {
    postconditions {
        new this.result == ( x*(y+z) == x*y + x*z );
    }
}

event distributiveInteger2(x: Integer, y: Money, z: Money) {
    postconditions {
        new this.result == ( (y+z)*x == y*x + z*x );
    }
}

event distributivePercentage1(x: Percentage, y: Money, z: Money) {
    postconditions {
        new this.result == ( x*(y+z) == x*y + x*z );
    }
}

event distributivePercentage2(x: Percentage, y: Money, z: Money) {
    postconditions {
        new this.result == ( (y+z)*x == y*x + z*x );
    }
}

event additiveIdentity1(x: Money) {
    postconditions {
        new this.result == ( x + EUR 0.00 == x );
    }
}

event additiveIdentity2(x: Money) {
    postconditions {
        new this.result == ( EUR 0.00 + x == x );
    }
}

event multiplicativeIdentity1(x: Money) {
    postconditions {
        new this.result == ( x*1 == x );
    }
}
event multiplicativeIdentity2(x: Money) {
    postconditions {
        new this.result == ( 1*x == x );
    }
}
\end{lstlisting}
\caption{The property definitions as \textit{Rebel} specification (continued)}
\end{sourcecode}
\FloatBarrier
% End listing
%
% Listing
\begin{sourcecode}[!ht]
\begin{lstlisting}[language=Rebel]
event additiveInverse1(x: Money) {
    postconditions {
        new this.result == ( x+(-x) == EUR 0.00 );
    }
}

event additiveInverse2(x: Money) {
    postconditions {
        new this.result == ( (-x)+x == EUR 0.00 );
    }
}

event antisymmetryLET(x: Money, y: Money) {
    postconditions {
        new this.result == ( (x <= y && y <= x) ? x == y : True );
    }
}

event antisymmetryGET(x: Money, y: Money) {
    postconditions {
        new this.result == ( (x >= y && y >= x) ? x == y : True );
    }
}

event division1(x: Money, y: Integer, z: Money) {
    postconditions {
        new this.result == ( (x*y == z) ? (x == z/y) : True );
    }
}

event division2(x: Money, y: Integer, z: Money) {
    postconditions {
        new this.result == ( (x == z*y) ? (x/y == z) : True );
    }
}

event multiplicativeZeroProperty1(x: Money) {
    postconditions {
        new this.result == ( x*0 == EUR 0.00 );
    }
}

event multiplicativeZeroProperty2(x: Money) {
    postconditions {
        new this.result == ( 0*x == EUR 0.00 );
    }
}

event anticommutativity(x: Money, y: Money) {
    postconditions {
        new this.result == ( x-y == -(y-x) );
    }
}

event nonassociativity(x: Money, y: Money, z: Money) {
    postconditions {
        new this.result == ( (x-y)-z != x-(y-z) );
    }
}

event trichotomy(x: Money, y: Money) {
    postconditions {
        new this.result == ( x < y || x == y || x > y );
    }
}
\end{lstlisting}
\caption{The property definitions as \textit{Rebel} specification (continued)}
\end{sourcecode}
\FloatBarrier
% End listing

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Appendix II:
\chapter{Additional property definitions}
\label{app:b_event_definitions_additional}
% Listing
\begin{sourcecode}[!ht]
\begin{lstlisting}[language=Rebel]
event divisionEquality1(x: Money, y: Integer, z: Money) {
    preconditions {
        round((x*y)) == round((z));
    }
    postconditions {
        new this.result == ( (round(x*y) == round(z)) ? (round(x) == round(z/y)) : False );
    }
}

event divisionEquality2(x: Money, y: Integer, z: Money) {
    preconditions {
        round((x)) == round((z*y));
    }
    postconditions {
        new this.result == ( (round(x) == round(z*y)) ? (round(x/y) == round(z)) : False );
    }
}

event divisionEquality3(x: Money, y: Money, z: Integer) {
    preconditions {
        x == y;
        z != 0;
    }
    postconditions {
        new this.result == ( (x == y && z != 0) ? (x/z == y/z) : False );
    }
}

event divisionInequalityLT1(x: Money, y: Money, z: Integer) {
    preconditions {
        x < y;
        z > 0;
    }
    postconditions {
        new this.result == ( (x < y && z > 0) ? (x/z < y/z) : False );
    }
}
\end{lstlisting}
\caption{Additional property definitions as \textit{Rebel} specification}
\end{sourcecode}
\FloatBarrier
% End listing
%
% Listing
\begin{sourcecode}[!ht]
\begin{lstlisting}[language=Rebel]
event divisionInequalityLT2(x: Money, y: Money, z: Integer) {
    preconditions {
        x < y;
        z < 0;
    }
    postconditions {
        new this.result == ( (x < y && z < 0) ? (x/z > y/z) : False );
    }
}

event divisionInequalityLGT1(x: Money, y: Money, z: Integer) {
    preconditions {
        x > y;
        z > 0;
    }
    postconditions {
        new this.result == ( (x > y && z > 0) ? (x/z > y/z) : False );
    }
}

event divisionInequalityLGT2(x: Money, y: Money, z: Integer) {
    preconditions {
        x > y;
        z < 0;
    }
    postconditions {
        new this.result == ( (x > y && z < 0) ? (x/z < y/z) : False );
    }
}

event additiveEquality(x: Money, y: Money, z: Money) {
    preconditions {
        x == y;
    }
    postconditions {
         new this.result == ( (x==y) ? x+z == y+z : False );
    }
}

event additiveEquality4params(x: Money, y: Money, z: Money, a: Money) {
    preconditions {
        x == y;
        z == a;
    }
    postconditions {
        new this.result == ( (x == y && z == a) ? x+z == y+a : False );
    }
}

event additiveInequalityLT(x: Money, y: Money, z: Money) {
    preconditions {
        x < y;
    }
    postconditions {
         new this.result == ( (x<y) ? x+z < y+z : False );
    }
}

event additiveInequalityGT(x: Money, y: Money, z: Money) {
    preconditions {
        x > y;
    }
    postconditions {
         new this.result == ( (x>y) ? x+z > y+z : False );
    }
}
\end{lstlisting}
\caption{Additional property definitions as \textit{Rebel} specification (continued)}
\end{sourcecode}
\FloatBarrier
% End listing
%
% Listing
\begin{sourcecode}[!ht]
\begin{lstlisting}[language=Rebel]
event subtractiveEquality(x: Money, y: Money, z: Money) {
    preconditions {
        x == y;
    }
    postconditions {
        new this.result == ( (x==y) ? (x-z == y-z) : False );
    }
}

event subtractiveInequalityLT(x: Money, y: Money, z: Money) {
    preconditions {
        x < y;
    }
    postconditions {
        new this.result == ( (x<y) ? (x-z < y-z) : False );
    }
}

event subtractiveInequalityGT(x: Money, y: Money, z: Money) {
    preconditions {
        x > y;
    }
    postconditions {
        new this.result == ( (x>y) ? (x-z > y-z) : False );
    }
}

event multiplicativeEquality(x: Money, y: Money, z: Integer) {
    preconditions {
        x == y;
    }
    postconditions {
        new this.result == ( (x==y) ? (x*z == y*z) : False );
    }
}

event multiplicativeInequalityLT1(x: Money, y: Money, z: Integer) {
    preconditions {
        x < y;
        z > 0;
    }
    postconditions {
        new this.result == ( (x<y && z > 0) ? (x*z < y*z) : False );
    }
}

event multiplicativeInequalityLT2(x: Money, y: Money, z: Integer) {
    preconditions {
        x < y;
        z < 0;
    }
    postconditions {
        new this.result == ( (x<y && z < 0) ? (x*z > y*z) : False );
    }
}

event multiplicativeInequalityGT1(x: Money, y: Money, z: Integer) {
    preconditions {
        x > y;
        z > 0;
    }
    postconditions {
        new this.result == ( (x>y && z > 0) ? (x*z > y*z) : False );
    }
}
\end{lstlisting}
\caption{Additional property definitions as \textit{Rebel} specification (continued)}
\end{sourcecode}
\FloatBarrier
% End listing
%
% Listing
\begin{sourcecode}[!ht]
\begin{lstlisting}[language=Rebel]
event multiplicativeInequalityGT2(x: Money, y: Money, z: Integer) {
    preconditions {
        x > y;
        z < 0;
    }
    postconditions {
        new this.result == ( (x>y && z < 0) ? (x*z < y*z) : False );
    }
}
\end{lstlisting}
\caption{Additional property definitions as \textit{Rebel} specification (continued)}
\end{sourcecode}
\FloatBarrier
% End listing
