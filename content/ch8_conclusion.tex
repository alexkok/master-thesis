% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Chapter: Conclusion
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter{Conclusion}
\label{chp:conclusion}
% Summary
In this thesis, we have shown a way how the generator can be tested by using property-based testing. This is done by generating tests based on the \textit{Rebel} specification and making use of the generator to generate the tests. The \textit{Rebel} specification is build up based on a set of defined properties of \textit{Rebel}. However, these definitions were not defined earlier, thus we define properties of \textit{Rebel} that are expected hold. We have found found some bugs in the generated system that were unknown before, by using the test framework that we created. This proves that this approach already worked to identify some problems in the generator that were not known before. Additionally, we contributed to an open-source library called \textit{Squants}, we issued two reports of bugs that existed in the library.\\
\\
% Research questions
% Answer main research question
To answer the main research question, we defined and answered the three sub research questions, which have been discussed in \autoref{cpt:discussion}. The main research question was as follows:
\begin{quote}
\rqMain
\end{quote}
A \textit{Rebel} specification was created from the defined properties. Next, the existing generator was being used to generate the SUT and to translate the properties (in the \textit{Rebel} specification) to test cases. When running the test suit against the generated system, we found some errors in the implementation of the generated system. Additionally, we were able to detect a compilation error and incorrectly translated formulas. Although the latter was not the case, we showed that this can be detected when modifying the generator such that a formula is being translated incorrectly.\\
\\
We conclude that this approach is a way how the implementation of the generator can be checked to satisfy certain properties that have been defined. However, it does not mean that there are no implementation errors in case the test suite finishes successfully. It only means that no implementation errors were found using this test framework. The test framework can be extended such that it covers more components of the implementation, or to cover additional properties of \textit{Rebel}.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Contribution
\section{Contribution}
% - Definitions (properties)
We provided a definition of some types in \textit{Rebel} and described properties that should hold when using operations with these types. Since there were no clear definitions available yet of what these types exactly do, a contribution has been made to the \textit{Rebel} project, such that there are now some definitions and properties available. This also helps when reasoning about the implementation, as there is now a definition of what is expected. Although these definitions might change over time, it allows to reason back to an earlier starting point.\\
\\
% - A way to automatically test the generator and generated system using Rebel, defining properties as events
We have shown a way to automatically test the generator using the \textit{Rebel} language and its toolchain, with the addition of our test framework. This is done by defining the properties that are expected to hold in the first case. Which can be translated to a \textit{Rebel} specification such that a system can be generated from it. Additionally using the generator when generating the test cases, so that the translation of expressions in the generator will be checked too. The different kind of properties should be able to detect unexpected behaviour.\\
\\
% - Found number of bugs in generated system
A number of bugs have been found in the generated system, precision errors, overflow/underflow errors and even a compile error. These bugs are now known issues in this project, while these were unknown before. This shows us that this approach already worked in such a way that it is able to detect bugs in the generated system. It can be extended to detect even more bugs. With some modifications, it is also possible to use this approach with other generated systems, such that it can detect inequalities among these.\\
\\
% - Squants issues
In this approach, we identified two bugs, which were due to an open-source library used in the generated
system, called \textit{Squants}. We reported these two issues, such that these can be fixed in a later version of the library.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Section: Future work
\section{Future work}
\todo{Write  this out. Points below are baselines for the content here}
- Generate properties (automatically) for each type, allowing dynamic adding of new operators and types. Or to detect errors in the typechecker. For example: if the type checker allows multiplication of Money, an error at compile or run time will occur in the generated system. Since this was not the aim of the project, it is not required, but can be useful to detect errors in the generated system when a new type has been added.  \\
- Dynamic values generation based on conditions. Maybe other tools can be used to do this or as guideline. (probably some QuickCheck variants support this already). Could use SMT for this, or a tool like SAGE (SRC).\\
- More properties, define more things to test. Also other types.\\
% - Sync properties. (Or maybe we do cover them later. At the moment of writing this is not the case yet)
- Support for checking other components, such as syncblock\\
% - Mutation checks if we catch invalid generations of the program. 'proving' that our suit is useful. (Although it already found bugs)
- Mutation coverage as measure to how effective this could be. Are all mutants killed? Available at bitcode level for Scala as it compiles to Java in the end. However, this might also generate mutants that are not being killed, as it might do some modifications that still result in a correct implementation.



% From old discussion
% Future work
\textit{Rebel} contains a type checker, which is able to determine exactly which operations are supported by using certain combinations of operators and types. This could be used to automatically generate the specifications for each type in \textit{Rebel}. Considering that a map of all operations can be created and a map of all existing types, each combination can be tested against the type checker. If the type checker allows determines it as a correct expression, an event definition in \textit{Rebel} could be created for it. Although this might result in many definitions that are being tested, with a possible overlap between them, it would be a way to automatically test each operation using different types. Furthermore, it can make it more dynamic when a new type could be added to \textit{Rebel}. However, this could be done in the future to extend the test framework.\\
\\
% > Future work
Another improvement could be to define the expected behaviour of the sync blocks that \textit{Rebel} supports, which hooks into the improvement point of missing properties. The current test framework is not able to test sync blocks at all, but this would be a useful improvement. There were already some known issues with the sync block expressions of which some have been fixed already. Furthermore, there is the expectation that the sync blocks implementation has more bugs.


% > Test mechanics and future work (Also handled in threat of test mechanics)
Throughout this project, we have only tested the system that is generated by the Scala/Akka generator which is developed by ING. Since there are more generators available, the test framework can be improved such that it is compatible with the other systems that can be generated by using one of the other generators that are available within ING. By doing this, the same property definitions can be tested on different kind of generated systems. This can be used to detect inequalities among the generated system.
% Optimizations: efficiency

% > Concolic testing? Satisfying properties, godefroid
